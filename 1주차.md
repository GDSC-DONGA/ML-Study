# 01. 행렬의 필요성
## 1) 행렬의 필요성
- 현실 세계의 많은 문제를 쉽게 해결 가능
- 복잡한 연립 방정식의 해를 구할 수 있음

## 2) 행렬의 쓰임 예시
- 컴퓨터의 메모리 구조 표현
- 표 형태의 데이터 표현
- 이미지 표현 (cf. 각각의 픽셀을 행렬로 표현)


cf.
  - 1차원 배열 : 백터
  - 2차원 배열 : 행렬
  - 3차원 배열 : 텐서

cf.
  - 더 자세한 내용은 선형대수학 공부
  - 인공지능, 머신러닝은 행렬 필수적
<hr>

# 02. 개발환경
## 1) PyCharm
- 가장 많은 사람들이 사용하는 파이썬 개발 환경

## 2) CoLab (=> Jupyter 기반)
- OpenCV를 포함한 이미지 처리 라이브러리가 기본적으로 설치되어 있음.
- GPU 런타임을 지원 (= GPU 연산을 지원 받을 수 있다.)
- 코드를 공유하며, 협업하기 좋음.

## 3) Repl.it
- 아무런 계정 없이 Python 개발 가능
- 여러 사람이 동시에 하나의 화면에서 코딩 가능
- 다양한 패키지를 검색해서 설치 가능
<hr>

# 03. Numpy의 기본 사용법
## 1) Numpy 란 ?
- 데이터 분석을 공부할 때 필수적으로 알아야 함.
- 다차원 배열을 효과적으로 처리할 수 있도록 도와줌.
- 현실 세계의 다양한 데이터는 배열 형태로 표현 가능.

## 2) Numpy의 차원
- 1차원 축(행) : axis 0 => Vector(벡터)
- 2차원 축(열) : axis 1 => Matrix(행렬)
- 3차원 축(채널) : axis 2 => Tensor(3차원 이상, 텐서)

## 3) Numpy의 기본 사용법
#### 가) List를 Numpy로 바꾸기
<pre><code>
import numpy as np

list_data = [1, 2, 3]
array = np.array(list_data)

print(array.size) 	#3
print(array.dtype) 	#int 64
print(array[1])		#2
</code></pre>
#### 나) Numpy 배열 초기화
<pre><code>
import numpy as np

array1 = np.arange(4)                       #0~3배열
array2 = np.zeros((4, 4), dtype=float)      #0으로 초기화
array3 = np.ones((3, 3), dtype=str)         #1로 초기화
array4 = np.random.randint(0, 10, (3, 3))   #0~9 랜덤 초기화
array5 = np.random.normal(0, 1, (3, 3))     #평균 0, 표준편차 1인 표준 정규 배열

print(array1)	#[0 1 2 3]
print(array2)	#[[0. 0. 0. 0.]]
print(array3)	#[['1' '1' '1' '1']]
print(array4)	#[[9 3 8 8]]
print(array5)	#[[-0.684376    1.74030087  0.2387887  -0.03009152]]
</code></pre>
#### 다) Numpy 배열 형태 바꾸기 (reshape)
<pre><code>
import numpy as np

array1 = np.array([1, 2, 3, 4])   #1차원 배열
array2 = array1.reshape((2, 2))   #2차원 배열

print(array1)	#[1 2 3 4]
print(array2)	#[[1 2]
 		# [3 4]]
</code></pre>
#### 라) Numpy 배열 (가로축으로)합치기 (concatenate)
<pre><code>
import numpy as np

array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])
array3 = np.concatenate([array1, array2])

print(array3.shape)		#6
print(array3)			#[1 2 3 4 5 6]
</code></pre>
#### 마) Numpy 배열 세로축으로 합치기
<pre><code>
import numpy as np

array1 = np.arange(4).reshape(1, 4)
array2 = np.arange(8).reshape(2, 4)
array3 = np.concatenate([array1, array2], axis=0)	#axis=0을 기준으로 합쳐짐.

print(array3.shape)		#(3, 4)
print(array3)			#[[0 1 2 3]
				# [0 1 2 3]
				# [4 5 6 7]]
</pre></code>
#### 바) Numpy 배열 나누기
<pre><code>
import numpy as np

array1 = np.arange(8).reshape(2, 4)
left, right = np.split(array1, [2], axis=1)   #인덱스 2의 axis=1(col)을 기준으로 나눈다.

print(f'{left.shape} & {right.shape}')	#(2, 2) & (2, 2)
print(f'{left[0]} & {right[0]}')	#[0 1] & [2 3]
print(f'{left[1]} & {right[1]}')	#[4 5] & [6 7]
</pre></code>
<hr>

# 04. Numpy의 기본 연산
## 1) Numpy의 기본 연산
- Numpy는 배열에 대한 기본적인 사칙연산을 지원

## 2) Numpy의 상수 연산
#### 가) 더하기 
- 배열(백터) + 숫자(스칼라) : 각각의 원소에 더하기 수행
<pre><code>
import numpy as np

array = np.random.randint(1, 10, size=4).reshape(2, 2)
add_array = array+10

print(f'{array[0]} => {add_array[0]}')	#[1 5] => [11 15]
print(f'{array[1]}    {add_array[1]}')	#[9 6]    [19 16]
</code></pre>
#### 나) 곱하기 
- 배열(백터) + 숫자(스칼라) : 각각의 원소에 곱하기 수행
<pre><code>
import numpy as np

array = np.random.randint(1, 10, size=4).reshape(2, 2)
mul_array = array*10

print(f'{array[0]} => {mul_array[0]}')	#[5 2] => [50 20]
print(f'{array[1]}    {mul_array[1]}')	#[2 6]    [20 60]
</code></pre>

## 3) Numpy의 서로 다른 형태의 연산 => 브로드캐스트
- 브로드캐스트 : 형태가 다른 배열을 연산할 수 있도록 배열의 형태를 동적으로 변환
![image](https://user-images.githubusercontent.com/115006161/198888340-ead7726a-51f2-4058-a665-d39693f1bae5.png)
<pre><code>
import numpy as np

array1 = np.arange(0,4).reshape(2, 2)
array2 = np.arange(0,2).reshape(2, 1)

print(f'{array1[0]} + {array2[0]} = {array1[0]+array2[0]}')	#[0 1] + [0] = [0 1]
print(f'{array1[1]}   {array2[1]} = {array1[1]+array2[1]}')	#[2 3]   [1] = [3 4]
</pre></code>

## 4) Numpy의 마스킹 연산
- 마스킹 : 각 원소에 대하여 체크
- 반복문을 이용할  때보다 매우 빠르게 동작
- 이미지 처리(Image Processing) or 데이터 분석을 할 때 많이 사용
    ex. 색상이 매우 밝은 픽셀 값만 뽑아내서 다르게 바꿀 수 있음.
![image](https://user-images.githubusercontent.com/115006161/198888410-2ed6071e-ed18-4309-bcd0-dcfd41daaf8f.png)
<pre><code>
import numpy as np

array  = np.arange(16).reshape(4, 4)
array1 = array < 10
array2 = np.arange(16).reshape(4, 4)
array2[array1]=100

print(f'{array[0]}=>{array1[0]}=>{array2[0]}') #[0 1 2 3]  =>  [ True  True  True  True]=>[100 100 100 100]
print(f'{array[1]}  {array1[1]}  {array2[1]}') #[4 5 6 7]      [ True  True  True  True]  [100 100 100 100]
print(f'{array[2]}  {array1[2]}  {array2[2]}') #[ 8  9 10 11]  [ True  True False False]  [100 100  10  11]
print(f'{array[3]}  {array1[3]}  {array2[3]}') #[12 13 14 15]  [False False False False]  [12 13 14 15]
</code></pre>

## 5) Numpy의 집계 함수
<pre><code>
import numpy as np

array  = np.arange(16).reshape(4, 4)

print(f'최대값 : {np.max(array)}')	#최대값 : 15
print(f'최소값 : {np.min(array)}')	#최소값 : 0
print(f'합계   : {np.sum(array)}')	#합계 : 120	#np.sum(array, axis=0):열에 대해 더함
print(f'평균값 : {np.mean(array)}')	#평균값 : 7.5
</pre></code>
<hr>

# 05. Numpy의 활용
## 1) Numpy의 저장과 불러오기
![image](https://user-images.githubusercontent.com/115006161/198888602-8451f52c-6068-4606-8074-72fe585ee426.png)
#### 가) 단일 객체 저장 및 불러오기 : np.save & .npy
<pre><code>
import numpy as np

array  = np.arange(0,10)
np.save('saved.npy', array)

file = np.load('saved.npy')

print(file)	#[0 1 2 3 4 5 6 7 8 9]
</code></pre>
#### 나) 복수 객체 저장 및 불러오기 : np.savez & .npz
<pre><code>
import numpy as np

array1 = np.arange(0, 10)
array2 = np.arange(10, 20)
np.savez('saved.npz', file1=array1, file2=array2)

data = np.load('saved.npz')
file1 = data['file1']
file2 = data['file2']

print(file1)	#[0 1 2 3 4 5 6 7 8 9]
print(file2)	#[10 11 12 13 14 15 16 17 18 19]
</code></pre>

## 2) Numpy 원소의 정렬
- 오름차순, 내림차순, 각 열을 기준으로 정렬
<pre><code>
import numpy as np

array = np.array([5, 9, 10, 3, 1])
array.sort()
array1 = np.array([[5, 9, 10, 3, 1], [8, 3, 4, 2, 5]])
array1.sort(axis=0)

print(f'기본배열 : {array}')			#기본배열 : [ 1  3  5  9 10]
print(f'오름차순 : {array}')			#오름차순 : [ 1  3  5  9 10]
print(f'내림차순 : {array[::-1]}')		#내림차순 : [10  9  5  3  1]
print(f'각 열을 기준으로 정렬 : {array1[0]}')	#각 열을 기준으로 정렬 : [5 3 4 2 1]
print(f'{array1[1]}')				#		        [8 9 10 3 5]
</code></pre>

## 3) 자주 사용되는 함수
- 균일한 간격으로 데이터 생성 (np.linspace)
- 난수 (np.random.randint)
- Numpy 배열 객체 복사(copy) 
    cf) 'array1 = array2' 형식으로 복사를 하게되면, array2 수정 시 array1도 바뀜.
- 중복된 원소 제거
<pre><code>
import numpy as np

array = np.array([1, 2, 2, 2, 3, 3])
균일_array = np.linspace(0, 10, 5)
난수_array = np.random.randint(0, 10, (2, 2)) #실행마다 결과 동일하게 하려면 seed() 함수 사용.
복사_array = 난수_array.copy()
중복제거_array = np.unique(array)

print(f'{균일_array}')		#[ 0. 2.5 5. 7.5 10. ]
print(f'{난수_array}')		#[[8 8] [7 5]]
print(f'{복사_array}')		#[[8 8] [7 5]]
print(f'{중복제거_array}')	#[1 2 3]
</code></pre>
